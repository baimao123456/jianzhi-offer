/*************************************/
//求1+2+...+n,不能用乘除法，循环、判断语句
/*************************************/
#include <iostream>
#include <list>
#include <algorithm>
using namespace std;
//*******************************************
//利用构造函数求解
//*******************************************
class Temp
{

public:
    Temp() { ++N ; Sum += N;}
    static void Reset() { N = 0; Sum = 0;}
    static unsigned int GetSum() { return Sum;}

private:
    static unsigned int N;
    static unsigned int Sum;
};
unsigned int Temp::N = 0;
unsigned int Temp::Sum = 0;
unsigned int Sum_Solution1(unsigned int n)
{
    Temp::Reset();

    Temp* a = new Temp[n];
    delete[] a;
    a = NULL;

    return Temp::GetSum();
}
//*******************************************
//利用虚函数求解
//*******************************************
class A;
A* Array[2];
class A
{
public:
    virtual unsigned int Sum(unsigned int n)
    {
        return 0;
    }
};
class B : public A
{
public:
    virtual unsigned int Sum(unsigned int n)
    {
        return Array[!!n]->Sum(n - 1) + n;  //如果n为0则返回0，通过n来选择条用哪个虚函数
    }
};
unsigned int Sum_Solution2(unsigned int n)
{
    A a;
    B b;
    Array[0] = &a;
    Array[1] = &b;

    return Array[1]->Sum(n);
}
//*******************************************
//利用函数指针求解
//*******************************************
typedef unsigned int (*fun)(unsigned int);    //声明一个函数指针类型

unsigned int Solution3_Teminator(unsigned int n);
unsigned int Sum_Solution3(unsigned int n);

static fun f[2] = {Solution3_Teminator, Sum_Solution3}; //数组内保存的是函数的地址

unsigned int Solution3_Teminator(unsigned int n)
{
    return 0;
}
unsigned int Sum_Solution3(unsigned int n)
{
    return n + f[!!n](n - 1);
}

//*******************************************
//利用模板类型求解
//*******************************************
template <unsigned int n> struct Sum_Solution4
{
    enum Value { N = Sum_Solution4<n - 1>::N + n};
};
template <> struct Sum_Solution4<1>
{
    enum Value { N = 1};
};
int main(void)
{

    cout << Sum_Solution1(3) << endl;
    cout << Sum_Solution2(3) << endl;
    cout << Sum_Solution3(3) << endl;
    cout << Sum_Solution4<3>::N << endl;
    return 0;
}
